# naku

暂时不跨平台，暂时仅支持linux

用自己的网络库来做http server, 如果好用可以用来写网盘服务端




把线程池去掉, 没必要, 把线程封装一下更好管理一点, 别通过索引去找线程之类的, 通过map, 通过线程id或名字???????



## 使用

- 参考examples
- 用户包含 include/naku.h 文件, 就可以使用

## 新增功能

1. 调度功能增强, 每次添加任务时, 对线程的任务数量进行排序, 可以保证优先向任务数量最小的线程添加任务
   采用堆排序(堆排序和快排哪个更好? 为什么计时器用堆排序?)

2. 一开始就创建2倍CPU核数的线程(2倍核数的线程不会造成大的调度压力, 是较好的线程数量),
   如果没有任务就使用信号量阻塞, 等待任务(减少消耗) 动态创建销毁线程没必要, 浪费时间和代码量
   一个公式: 线程数 = CPU 核心数 * (1+ IO 耗时/CPU 耗时)

3. 协程池全局只有一个实例（单例模式）, 用户使用co_run函数可以直接创建协程，
   不需要用户管理netio_copool协程池对象, 所有协程都运行在全局协程池中

4. 封装mutex(应该封装不了), 但是就怕lock时阻塞住协程了, 而unlock的协程运行不到就死锁了
   参考一下微信的libcco

5. 日志参考spdlog高性能异步日志库

## 目录结构

- 保存内部实现使用的头文件和实现

```
${PROJECT}/include/base
${PROJECT}/naku/base
```

- 保存对外的头文件和实现

```
${PROJECT}/include
${PROJECT}/naku
```

